struct stHoneycombs{
    uint uintHoneycombs[14];
    float divider;
    float counter;
};

RWStructuredBuffer<stHoneycombs> Atomsroommates;
RWStructuredBuffer<int> RegulatorTick;
RWStructuredBuffer<float4> PositionAtoms;
RWStructuredBuffer<int> StCountr;
//float arrtrifloats[1];
uint quantity;

#pragma kernel AtomGroup
[numthreads(1,1,1)]
void AtomGroup (uint3 id : SV_DispatchThreadID)
{
    float4 ChanPositionAtoms = 0;
    if(RegulatorTick[0] == 1) //тик
    {
        if(Atomsroommates[id.x].counter >= Atomsroommates[id.x].divider)
        {
        ChanPositionAtoms = float4(0.1, RegulatorTick[0], 0.1, 0.1) * 1;
        Atomsroommates[id.x].counter = 0;
        PositionAtoms[id.x] += ChanPositionAtoms;
        }Atomsroommates[id.x].counter++;
    }
    else if(RegulatorTick[0] == 0) //Старт тик
    {

        if(StCountr[id.x] < quantity)
        {
            StCountr[id.x]++;
        }else{
            RegulatorTick[0] = 1;
        }
        Atomsroommates[id.x].uintHoneycombs[0] = 0;//x
        Atomsroommates[id.x].uintHoneycombs[1] = 1;//-x
        Atomsroommates[id.x].uintHoneycombs[2] = 2;//y
        Atomsroommates[id.x].uintHoneycombs[3] = 0;//-y
        Atomsroommates[id.x].uintHoneycombs[4] = 0;//z
        Atomsroommates[id.x].uintHoneycombs[5] = 0;//-z
        Atomsroommates[id.x].divider = 10000;
        Atomsroommates[id.x].counter = 0;
        
    }
    //         1047999
    /*Atomsroommates[id.x].uintHoneycombs[1] += 1;
    MendeleevTable[id.x] = 1;
    
    PositionAtoms[id.x] = float4(Atomsroommates[id.x].uintHoneycombs[1], id.x , id.x, id.x); */
    //PositionAtoms[id.x] += float4(0, 0, id.x * 0.0001, id.x * 0.0001);
    /*if (false){
    PositionAtoms[id.x] = float4(Atomsroommates[id.x].uintHoneycombs[1], id.x , id.x, id.x);
    }else{
    PositionAtoms[id.x] += float4(Atomsroommates[id.x].uintHoneycombs[1], id.x , id.x, id.x);
    }*/
}
